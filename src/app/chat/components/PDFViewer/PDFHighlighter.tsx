'use client';

import React, { useEffect, useState, useRef } from 'react';
import { HighlightRange } from '../../types/source';
import styles from './PDFHighlighter.module.scss';

interface PDFHighlighterProps {
  pageNumber: number;
  highlightRange: HighlightRange;
  scale: number;
  pageWidth: number;
  pageHeight: number;
  textContent?: any; // PDF.js TextContent
}


interface HighlightBox {
  top: number;
  left: number;
  width: number;
  height: number;
  type: 'text' | 'image' | 'table';
}

const PDFHighlighter: React.FC<PDFHighlighterProps> = ({
  pageNumber,
  highlightRange,
  scale,
  pageWidth,
  pageHeight,
  textContent
}) => {
  const [highlightBoxes, setHighlightBoxes] = useState<HighlightBox[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);

  // ÌòÑÏû¨ ÌéòÏù¥ÏßÄÍ∞Ä ÌïòÏù¥ÎùºÏù¥Ìä∏ ÎåÄÏÉÅÏù∏ÏßÄ ÌôïÏù∏
  const shouldHighlight = pageNumber === highlightRange.pageNumber;

  // TextLayerÏóêÏÑú Ïã§Ï†ú ÌÖçÏä§Ìä∏ ÏöîÏÜåÎ•º Ï∞æÏïÑ ÎùºÏù∏Î≥ÑÎ°ú Ï†ïÌôïÌïòÍ≤å Í∑∏Î£πÌôî
  const findTextElements = () => {
    console.log('üîç [PDF Highlighter] Starting findTextElements...');
    
    if (!containerRef.current || !shouldHighlight) {
      console.log('‚ùå [PDF Highlighter] Early return:', { 
        containerExists: !!containerRef.current, 
        shouldHighlight 
      });
      return [];
    }

    console.log('üìç [PDF Highlighter] Container ref found:', containerRef.current);
    
    const textLayerDiv = containerRef.current.parentElement?.querySelector('.react-pdf__Page__textContent');
    console.log('üìÑ [PDF Highlighter] TextLayer div:', textLayerDiv);
    
    if (!textLayerDiv) {
      console.log('‚ùå [PDF Highlighter] No textLayer div found');
      // ÎåÄÏïà ÌÉêÏÉâ
      const allTextLayers = document.querySelectorAll('.react-pdf__Page__textContent');
      console.log('üîç [PDF Highlighter] Available text layers in document:', allTextLayers.length);
      allTextLayers.forEach((layer, index) => {
        console.log(`üìã [PDF Highlighter] Text layer ${index}:`, layer);
      });
      return [];
    }

    const textSpans = Array.from(textLayerDiv.querySelectorAll('span')) as HTMLSpanElement[];
    console.log(`üìù [PDF Highlighter] Found ${textSpans.length} text spans`);
    
    if (textSpans.length === 0) {
      console.log('‚ùå [PDF Highlighter] No text spans found');
      return [];
    }

    // ÌÖçÏä§Ìä∏ ÏöîÏÜåÎì§ÏùÑ Y Ï¢åÌëúÎ°ú Ï†ïÎ†¨
    console.log('üìê [PDF Highlighter] Processing span positions...');
    const containerRect = textLayerDiv.getBoundingClientRect();
    console.log('üì¶ [PDF Highlighter] Container rect:', {
      top: containerRect.top,
      left: containerRect.left,
      width: containerRect.width,
      height: containerRect.height
    });

    const sortedSpans = textSpans
      .map((span, index) => {
        const rect = span.getBoundingClientRect();
        const spanData = {
          span,
          index,
          top: rect.top - containerRect.top,
          left: rect.left - containerRect.left,
          bottom: rect.bottom - containerRect.top,
          width: rect.width,
          height: rect.height,
          text: span.textContent || ''
        };
        
        if (index < 5) { // Ï≤òÏùå 5Í∞úÎßå Î°úÍ∑∏
          console.log(`üìù [PDF Highlighter] Span ${index}:`, {
            text: `"${spanData.text}"`,
            position: `(${spanData.left.toFixed(1)}, ${spanData.top.toFixed(1)})`,
            size: `${spanData.width.toFixed(1)}x${spanData.height.toFixed(1)}`
          });
        }
        
        return spanData;
      })
      .sort((a, b) => a.top - b.top);
      
    console.log(`üìä [PDF Highlighter] Sorted ${sortedSpans.length} spans by Y position`);

    // ÎùºÏù∏ Í∑∏Î£πÌôî - Îçî Ï†ïÌôïÌïú ÏïåÍ≥†Î¶¨Ï¶ò
    console.log('üìã [PDF Highlighter] Starting line grouping...');
    const lines: HTMLSpanElement[][] = [];
    let currentLineSpans: HTMLSpanElement[] = [];
    let currentLineTop = -1;
    let currentLineBottom = -1;
    let lineNumber = 0;

    sortedSpans.forEach(({ span, top, bottom, text, index }) => {
      // ÎùºÏù∏ ÎÜíÏù¥Ïùò Ï†àÎ∞ò Ïù¥ÏÉÅ Í≤πÏπòÎ©¥ Í∞ôÏùÄ ÎùºÏù∏ÏúºÎ°ú Í∞ÑÏ£º
      const lineHeight = bottom - top;
      const tolerance = Math.max(3, lineHeight * 0.3); // ÏµúÏÜå 3px ÎòêÎäî ÎùºÏù∏ ÎÜíÏù¥Ïùò 30%

      const isNewLine = currentLineTop === -1 || top > currentLineBottom - tolerance;

      if (isNewLine) {
        // ÏÉàÎ°úÏö¥ ÎùºÏù∏ ÏãúÏûë
        if (currentLineSpans.length > 0) {
          lines.push([...currentLineSpans]);
          console.log(`üìÑ [PDF Highlighter] Line ${lineNumber} completed with ${currentLineSpans.length} spans:`, 
            currentLineSpans.map(s => `"${s.textContent}"`).join(' '));
          lineNumber++;
        }
        currentLineSpans = [span];
        currentLineTop = top;
        currentLineBottom = bottom;
        console.log(`üÜï [PDF Highlighter] Starting new line ${lineNumber} with span ${index}: "${text}" at Y=${top.toFixed(1)}`);
      } else {
        // Í∞ôÏùÄ ÎùºÏù∏Ïóê Ï∂îÍ∞Ä
        currentLineSpans.push(span);
        currentLineTop = Math.min(currentLineTop, top);
        currentLineBottom = Math.max(currentLineBottom, bottom);
        console.log(`‚ûï [PDF Highlighter] Adding to line ${lineNumber}, span ${index}: "${text}" (tolerance: ${tolerance.toFixed(1)})`);
      }
    });

    // ÎßàÏßÄÎßâ ÎùºÏù∏ Ï∂îÍ∞Ä
    if (currentLineSpans.length > 0) {
      lines.push(currentLineSpans);
      console.log(`üìÑ [PDF Highlighter] Final line ${lineNumber} completed with ${currentLineSpans.length} spans:`, 
        currentLineSpans.map(s => `"${s.textContent}"`).join(' '));
    }
    
    console.log(`‚úÖ [PDF Highlighter] Line grouping complete: ${lines.length} lines found`);

    // Í∞Å ÎùºÏù∏ ÎÇ¥ÏóêÏÑú X Ï¢åÌëúÎ°ú Ï†ïÎ†¨
    lines.forEach(line => {
      line.sort((a, b) => {
        const rectA = a.getBoundingClientRect();
        const rectB = b.getBoundingClientRect();
        return rectA.left - rectB.left;
      });
    });

    return lines;
  };

  // Ïù¥ÎØ∏ÏßÄÏôÄ ÌÖåÏù¥Î∏î ÏöîÏÜåÎì§ÏùÑ Y Ï¢åÌëúÏôÄ Ìï®Íªò Ï∞æÏïÑ ÌïòÏù¥ÎùºÏù¥ÌåÖ
  const findImageAndTableElements = () => {
    console.log('üñºÔ∏è [PDF Highlighter] Starting findImageAndTableElements...');
    
    if (!containerRef.current || !shouldHighlight) {
      console.log('‚ùå [PDF Highlighter] Early return from findImageAndTableElements:', { 
        containerExists: !!containerRef.current, 
        shouldHighlight 
      });
      return [];
    }

    const pageElement = containerRef.current.parentElement;
    console.log('üìÑ [PDF Highlighter] Page element for image search:', pageElement);
    
    if (!pageElement) {
      console.log('‚ùå [PDF Highlighter] No page element found for image search');
      return [];
    }

    const elements: Array<HighlightBox & { yPosition: number }> = [];

    // SVG ÏöîÏÜåÎì§ (Ïù¥ÎØ∏ÏßÄÎÇò Í∑∏ÎûòÌîΩ ÏöîÏÜåÎ°ú Í∞ÑÏ£º)
    const svgElements = pageElement.querySelectorAll('svg');
    console.log(`üé® [PDF Highlighter] Found ${svgElements.length} SVG elements`);
    
    svgElements.forEach((svg, index) => {
      const rect = svg.getBoundingClientRect();
      const containerRect = pageElement.getBoundingClientRect();
      
      const element = {
        top: rect.top - containerRect.top,
        left: rect.left - containerRect.left,
        width: rect.width,
        height: rect.height,
        type: 'image' as const,
        yPosition: rect.top - containerRect.top
      };
      
      console.log(`üé® [PDF Highlighter] SVG ${index}:`, {
        position: `(${element.left.toFixed(1)}, ${element.top.toFixed(1)})`,
        size: `${element.width.toFixed(1)}x${element.height.toFixed(1)}`,
        element: svg
      });
      
      elements.push(element);
    });

    // Canvas ÏöîÏÜåÎì§ (Ïù¥ÎØ∏ÏßÄÎ°ú Í∞ÑÏ£º)
    const canvasElements = pageElement.querySelectorAll('canvas');
    console.log(`üñºÔ∏è [PDF Highlighter] Found ${canvasElements.length} Canvas elements`);
    
    canvasElements.forEach((canvas, index) => {
      const rect = canvas.getBoundingClientRect();
      const containerRect = pageElement.getBoundingClientRect();
      
      const element = {
        top: rect.top - containerRect.top,
        left: rect.left - containerRect.left,
        width: rect.width,
        height: rect.height,
        type: 'image' as const,
        yPosition: rect.top - containerRect.top
      };
      
      console.log(`üñºÔ∏è [PDF Highlighter] Canvas ${index}:`, {
        position: `(${element.left.toFixed(1)}, ${element.top.toFixed(1)})`,
        size: `${element.width.toFixed(1)}x${element.height.toFixed(1)}`,
        element: canvas
      });
      
      elements.push(element);
    });

    // Path ÏöîÏÜåÎì§ (ÎèÑÌòïÏù¥ÎÇò Í∑∏ÎûòÌîΩ ÏöîÏÜåÎ°ú Í∞ÑÏ£º)
    const pathElements = pageElement.querySelectorAll('path');
    pathElements.forEach(path => {
      const parentSvg = path.closest('svg');
      if (parentSvg) {
        const rect = parentSvg.getBoundingClientRect();
        const containerRect = pageElement.getBoundingClientRect();
        
        // Ï§ëÎ≥µ Î∞©ÏßÄÎ•º ÏúÑÌï¥ Ïù¥ÎØ∏ Ï∂îÍ∞ÄÎêú SVGÏù∏ÏßÄ ÌôïÏù∏
        const alreadyExists = elements.some(el => 
          Math.abs(el.top - (rect.top - containerRect.top)) < 1 &&
          Math.abs(el.left - (rect.left - containerRect.left)) < 1
        );
        
        if (!alreadyExists) {
          elements.push({
            top: rect.top - containerRect.top,
            left: rect.left - containerRect.left,
            width: rect.width,
            height: rect.height,
            type: 'image',
            yPosition: rect.top - containerRect.top
          });
        }
      }
    });

    return elements;
  };

  // ÌÖåÏù¥Î∏î Ìå®ÌÑ¥ Í∞êÏßÄ (ÌÖçÏä§Ìä∏ Í∏∞Î∞ò) - Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ
  const detectTablePatterns = (lines: HTMLSpanElement[][], targetLineStart: number, targetLineEnd: number) => {
    const tableElements: Array<HighlightBox & { lineNumbers: number[] }> = [];
    
    if (lines.length < 2) return tableElements;

    // ÏßÄÏ†ïÎêú ÎùºÏù∏ Î≤îÏúÑÏóêÏÑú ÌÖåÏù¥Î∏î Ìå®ÌÑ¥ Ï∞æÍ∏∞
    const startIndex = Math.max(0, targetLineStart - 1);
    const endIndex = Math.min(lines.length - 1, targetLineEnd - 1);
    
    // Ïó∞ÏÜçÎêú ÎùºÏù∏Îì§Ïù¥ Ï†ïÎ†¨Îêú Ïó¥ Íµ¨Ï°∞Î•º Í∞ÄÏßÄÎäîÏßÄ ÌôïÏù∏
    for (let i = startIndex; i <= endIndex && i < lines.length - 1; i++) {
      const currentLine = lines[i];
      const nextLine = lines[i + 1];
      
      if (currentLine.length >= 2 && nextLine.length >= 2) {
        // Í∞Å ÎùºÏù∏Ïùò ÏöîÏÜåÎì§Ïù¥ ÎπÑÏä∑Ìïú X Ï¢åÌëúÏóê Ï†ïÎ†¨ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        const currentPositions = currentLine.map(span => {
          const rect = span.getBoundingClientRect();
          return {
            left: rect.left,
            right: rect.right,
            text: span.textContent?.trim() || ''
          };
        });
        
        const nextPositions = nextLine.map(span => {
          const rect = span.getBoundingClientRect();
          return {
            left: rect.left,
            right: rect.right,
            text: span.textContent?.trim() || ''
          };
        });
        
        let alignedColumns = 0;
        const tolerance = 15; // 15px Ïò§Ï∞® ÌóàÏö©
        
        // ÌÉ≠Ïù¥ÎÇò Í≥µÎ∞±ÏúºÎ°ú Íµ¨Î∂ÑÎêú Ïó¥ Íµ¨Ï°∞ ÌôïÏù∏
        for (const currPos of currentPositions) {
          for (const nextPos of nextPositions) {
            if (Math.abs(currPos.left - nextPos.left) <= tolerance) {
              alignedColumns++;
              break;
            }
          }
        }
        
        // Ï†ïÎ†¨Îêú Ïó¥Ïù¥ 2Í∞ú Ïù¥ÏÉÅÏù¥Í≥†, Ïà´ÏûêÎÇò ÌäπÏ†ï Ìå®ÌÑ¥Ïù¥ ÏûàÏúºÎ©¥ ÌÖåÏù¥Î∏îÎ°ú Í∞ÑÏ£º
        const hasTabularData = currentPositions.some(pos => 
          /^\d+(\.\d+)?$/.test(pos.text) || // Ïà´Ïûê
          /^\$\d+/.test(pos.text) || // Í∏àÏï°
          /^\d{4}-\d{2}-\d{2}/.test(pos.text) || // ÎÇ†Ïßú
          pos.text.length <= 3 // ÏßßÏùÄ ÏΩîÎìúÎÇò ÏïΩÏñ¥
        );
        
        if (alignedColumns >= 2 && hasTabularData) {
          const firstSpan = currentLine[0];
          const lastSpan = currentLine[currentLine.length - 1];
          const firstRect = firstSpan.getBoundingClientRect();
          const lastRect = lastSpan.getBoundingClientRect();
          
          if (containerRef.current) {
            const containerRect = containerRef.current.getBoundingClientRect();
            
            // Îã§Ïùå ÎùºÏù∏ÍπåÏßÄ Ìè¨Ìï®Ìïú ÌÖåÏù¥Î∏î ÏòÅÏó≠
            const nextFirstSpan = nextLine[0];
            const nextLastSpan = nextLine[nextLine.length - 1];
            const nextFirstRect = nextFirstSpan.getBoundingClientRect();
            const nextLastRect = nextLastSpan.getBoundingClientRect();
            
            tableElements.push({
              top: firstRect.top - containerRect.top,
              left: Math.min(firstRect.left, nextFirstRect.left) - containerRect.left,
              width: Math.max(lastRect.right, nextLastRect.right) - Math.min(firstRect.left, nextFirstRect.left),
              height: (nextLastRect.bottom - firstRect.top),
              type: 'table',
              lineNumbers: [i + 1, i + 2] // 1-based line numbers
            });
          }
        }
      }
    }
    
    return tableElements;
  };

  useEffect(() => {
    if (!shouldHighlight) {
      setHighlightBoxes([]);
      return;
    }

    // DOMÏù¥ ÏóÖÎç∞Ïù¥Ìä∏Îêú ÌõÑ Ïã§ÌñâÌïòÍ∏∞ ÏúÑÌï¥ setTimeout ÏÇ¨Ïö©
    const timer = setTimeout(() => {
      console.log('üöÄ [PDF Highlighter] Starting highlighting process...');
      console.log('üéØ [PDF Highlighter] Target:', {
        page: pageNumber,
        highlightPage: highlightRange.pageNumber,
        lineStart: highlightRange.lineStart,
        lineEnd: highlightRange.lineEnd,
        shouldHighlight
      });
      
      const lines = findTextElements();
      console.log(`üìö [PDF Highlighter] Found ${lines.length} lines total`);
      
      // Í∞Å ÎùºÏù∏Ïùò ÎÇ¥Ïö©ÏùÑ Î°úÍ∑∏
      lines.forEach((line, index) => {
        const lineText = line.map(span => span.textContent).join(' ');
        console.log(`üìÑ [PDF Highlighter] Line ${index + 1}: "${lineText}"`);
      });
      
      const imageElements = findImageAndTableElements();
      console.log(`üñºÔ∏è [PDF Highlighter] Found ${imageElements.length} image elements`);
      
      const tableElements = detectTablePatterns(lines, highlightRange.lineStart, highlightRange.lineEnd);
      console.log(`üìä [PDF Highlighter] Found ${tableElements.length} table elements`);
      
      const boxes: HighlightBox[] = [];

      // ÏßÄÏ†ïÎêú ÎùºÏù∏ Î≤îÏúÑÏùò ÌÖçÏä§Ìä∏ ÌïòÏù¥ÎùºÏù¥ÌåÖ
      const startLine = highlightRange.lineStart - 1; // 0-based index
      const endLine = highlightRange.lineEnd - 1;
      
      console.log('üî¢ [PDF Highlighter] Target line indices:', {
        startLine: startLine,
        endLine: endLine,
        totalLines: lines.length
      });

      // ÎùºÏù∏Î≥Ñ Y Ï¢åÌëú Î≤îÏúÑ Í≥ÑÏÇ∞
      let lineYMin = Infinity;
      let lineYMax = -Infinity;

      for (let lineIndex = startLine; lineIndex <= endLine && lineIndex < lines.length; lineIndex++) {
        const lineSpans = lines[lineIndex];
        console.log(`üéØ [PDF Highlighter] Processing target line ${lineIndex + 1} (0-based: ${lineIndex})`);
        
        if (!lineSpans || lineSpans.length === 0) {
          console.log(`‚ö†Ô∏è [PDF Highlighter] Line ${lineIndex + 1} is empty or undefined`);
          continue;
        }

        console.log(`üìù [PDF Highlighter] Line ${lineIndex + 1} has ${lineSpans.length} spans:`, 
          lineSpans.map(span => `"${span.textContent}"`).join(' '));

        // ÎùºÏù∏Ïùò Ï≤´ Î≤àÏß∏ÏôÄ ÎßàÏßÄÎßâ ÏöîÏÜåÏùò ÏúÑÏπòÎ•º Í∏∞Î∞òÏúºÎ°ú ÌïòÏù¥ÎùºÏù¥Ìä∏ Î∞ïÏä§ ÏÉùÏÑ±
        const firstSpan = lineSpans[0];
        const lastSpan = lineSpans[lineSpans.length - 1];
        
        const firstRect = firstSpan.getBoundingClientRect();
        const lastRect = lastSpan.getBoundingClientRect();
        
        console.log(`üìê [PDF Highlighter] Line ${lineIndex + 1} bounds:`, {
          firstSpan: {
            text: firstSpan.textContent,
            rect: { top: firstRect.top, left: firstRect.left, width: firstRect.width, height: firstRect.height }
          },
          lastSpan: {
            text: lastSpan.textContent,
            rect: { top: lastRect.top, left: lastRect.left, width: lastRect.width, height: lastRect.height }
          }
        });
        
        if (containerRef.current) {
          const containerRect = containerRef.current.getBoundingClientRect();
          
          const lineTop = firstRect.top - containerRect.top;
          const lineBottom = firstRect.bottom - containerRect.top;
          const lineLeft = firstRect.left - containerRect.left;
          const lineWidth = (lastRect.right - firstRect.left);
          
          lineYMin = Math.min(lineYMin, lineTop);
          lineYMax = Math.max(lineYMax, lineBottom);
          
          const highlightBox = {
            top: lineTop,
            left: lineLeft,
            width: lineWidth,
            height: firstRect.height,
            type: 'text' as const
          };
          
          console.log(`‚úÖ [PDF Highlighter] Created highlight box for line ${lineIndex + 1}:`, {
            position: `(${lineLeft.toFixed(1)}, ${lineTop.toFixed(1)})`,
            size: `${lineWidth.toFixed(1)}x${firstRect.height.toFixed(1)}`,
            relativeToContainer: true
          });
          
          boxes.push(highlightBox);
        }
      }
      
      console.log(`üìè [PDF Highlighter] Text lines Y range: ${lineYMin === Infinity ? 'none' : lineYMin.toFixed(1)} - ${lineYMax === -Infinity ? 'none' : lineYMax.toFixed(1)}`);

      // ÎùºÏù∏ Î≤îÏúÑÏóê Ìè¨Ìï®Îêú Ïù¥ÎØ∏ÏßÄ ÏöîÏÜåÎì§ Ï∂îÍ∞Ä (Y Ï¢åÌëú Í∏∞Î∞ò Îß§Ïπ≠)
      console.log('üñºÔ∏è [PDF Highlighter] Processing image elements...');
      imageElements.forEach((element, index) => {
        // Y Ï¢åÌëú Í∏∞Î∞òÏúºÎ°ú ÎùºÏù∏ Î≤îÏúÑÏôÄ Í≤πÏπòÎäîÏßÄ ÌôïÏù∏
        const elementTop = element.yPosition;
        const elementBottom = element.yPosition + element.height;
        
        // Ïó¨Ïú†Î•º ÎëêÍ≥† Í≤πÏπ® ÌôïÏù∏ (ÎùºÏù∏ ÎÜíÏù¥Ïùò 50% Ï†ïÎèÑ)
        const tolerance = 20;
        
        console.log(`üñºÔ∏è [PDF Highlighter] Image ${index}:`, {
          position: `Y: ${elementTop.toFixed(1)} - ${elementBottom.toFixed(1)}`,
          size: `${element.width.toFixed(1)}x${element.height.toFixed(1)}`,
          textRangeY: lineYMin !== Infinity ? `${lineYMin.toFixed(1)} - ${lineYMax.toFixed(1)}` : 'none',
          tolerance
        });
        
        if (lineYMin !== Infinity && lineYMax !== -Infinity) {
          const overlaps = (elementTop <= lineYMax + tolerance && elementBottom >= lineYMin - tolerance) ||
                          (elementTop >= lineYMin - tolerance && elementTop <= lineYMax + tolerance);
                          
          console.log(`üñºÔ∏è [PDF Highlighter] Image ${index} overlaps with text: ${overlaps}`);
          
          if (overlaps) {
            const { yPosition, ...boxWithoutY } = element;
            boxes.push(boxWithoutY);
            console.log(`‚úÖ [PDF Highlighter] Added image ${index} to highlight boxes`);
          }
        }
      });

      // ÌÖåÏù¥Î∏î ÏöîÏÜåÎì§ Ï∂îÍ∞Ä (Ïù¥ÎØ∏ ÎùºÏù∏ Î≤îÏúÑ ÎÇ¥ÏóêÏÑú Í∞êÏßÄÎê®)
      console.log('üìä [PDF Highlighter] Processing table elements...');
      tableElements.forEach((element, index) => {
        console.log(`üìä [PDF Highlighter] Table ${index}:`, {
          lineNumbers: element.lineNumbers,
          position: `(${element.left.toFixed(1)}, ${element.top.toFixed(1)})`,
          size: `${element.width.toFixed(1)}x${element.height.toFixed(1)}`
        });
        
        const { lineNumbers, ...boxWithoutLineNumbers } = element;
        boxes.push(boxWithoutLineNumbers);
        console.log(`‚úÖ [PDF Highlighter] Added table ${index} to highlight boxes`);
      });

      // ÌÖçÏä§Ìä∏Í∞Ä ÏóÜÍ≥† Ïù¥ÎØ∏ÏßÄÎÇò ÌÖåÏù¥Î∏îÎßå ÏûàÎäî Í≤ΩÏö∞ Ï≤òÎ¶¨
      if (boxes.filter(box => box.type === 'text').length === 0 && (imageElements.length > 0 || tableElements.length > 0)) {
        // ÏßÄÏ†ïÎêú ÎùºÏù∏ Î≤îÏúÑÏóê Ìï¥ÎãπÌïòÎäî Ï∂îÏ†ï Y Ï¢åÌëú Í≥ÑÏÇ∞
        if (lines.length > 0) {
          const estimatedLineHeight = 16; // Í∏∞Î≥∏ ÎùºÏù∏ ÎÜíÏù¥
          const pageTopOffset = 50; // ÌéòÏù¥ÏßÄ ÏÉÅÎã® Ïó¨Î∞± Ï∂îÏ†ï
          
          const estimatedTop = pageTopOffset + (startLine * estimatedLineHeight);
          const estimatedBottom = pageTopOffset + ((endLine + 1) * estimatedLineHeight);
          
          imageElements.forEach(element => {
            const elementTop = element.yPosition;
            const elementBottom = element.yPosition + element.height;
            
            if (elementTop <= estimatedBottom && elementBottom >= estimatedTop) {
              const { yPosition, ...boxWithoutY } = element;
              boxes.push(boxWithoutY);
            }
          });
        }
      }

      // ÏµúÏ¢Ö Í≤∞Í≥º Î°úÍ∑∏
      const textBoxes = boxes.filter(box => box.type === 'text');
      const imageBoxes = boxes.filter(box => box.type === 'image');
      const tableBoxes = boxes.filter(box => box.type === 'table');
      
      console.log('üéâ [PDF Highlighter] Final Results:', {
        targetLines: `${highlightRange.lineStart}-${highlightRange.lineEnd}`,
        totalLinesFound: lines.length,
        textBoxesCreated: textBoxes.length,
        imageBoxesCreated: imageBoxes.length,
        tableBoxesCreated: tableBoxes.length,
        lineYRange: lineYMin !== Infinity ? `${lineYMin.toFixed(1)}-${lineYMax.toFixed(1)}` : 'not found',
        totalBoxes: boxes.length
      });
      
      // Í∞Å Î∞ïÏä§Ïùò ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Î°úÍ∑∏
      boxes.forEach((box, index) => {
        console.log(`üì¶ [PDF Highlighter] Box ${index} (${box.type}):`, {
          position: `(${box.left.toFixed(1)}, ${box.top.toFixed(1)})`,
          size: `${box.width.toFixed(1)}x${box.height.toFixed(1)}`
        });
      });
      
      if (boxes.length === 0) {
        console.warn('‚ö†Ô∏è [PDF Highlighter] No highlight boxes created! Check:');
        console.warn('   1. Are we on the correct page?', pageNumber, 'vs', highlightRange.pageNumber);
        console.warn('   2. Do the target lines exist?', `${highlightRange.lineStart}-${highlightRange.lineEnd}`, 'vs', lines.length, 'total lines');
        console.warn('   3. Is the TextLayer properly rendered?');
        console.warn('   4. Are the DOM elements accessible?');
      }

      setHighlightBoxes(boxes);
    }, 100);

    return () => clearTimeout(timer);
  }, [shouldHighlight, highlightRange, scale, pageWidth, pageHeight, textContent]);

  if (!shouldHighlight || highlightBoxes.length === 0) {
    return null;
  }

  return (
    <div ref={containerRef} className={styles.highlightContainer}>
      {highlightBoxes.map((box, index) => (
        <div
          key={index}
          className={`${styles.highlightBox} ${styles[`highlight${box.type.charAt(0).toUpperCase() + box.type.slice(1)}`]}`}
          style={{
            top: `${box.top}px`,
            left: `${box.left}px`,
            width: `${box.width}px`,
            height: `${box.height}px`,
          }}
        />
      ))}
      
      {/* ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï†ïÎ≥¥ ÎùºÎ≤® */}
      <div className={styles.highlightLabel}>
        ÎùºÏù∏ {highlightRange.lineStart}
        {highlightRange.lineStart !== highlightRange.lineEnd && 
          `-${highlightRange.lineEnd}`
        }
        <span className={styles.contentTypes}>
          {highlightBoxes.filter(box => box.type === 'text').length > 0 && ' üìù'}
          {highlightBoxes.filter(box => box.type === 'image').length > 0 && ' üì∑'}
          {highlightBoxes.filter(box => box.type === 'table').length > 0 && ' üìä'}
        </span>
        {highlightBoxes.length > 0 && (
          <div className={styles.contentCount}>
            {highlightBoxes.length}Í∞ú ÏöîÏÜå Í∞êÏßÄ
          </div>
        )}
      </div>
    </div>
  );
};

export default PDFHighlighter;